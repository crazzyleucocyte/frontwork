<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열</title>
    <style>
        .area {
            border: 1px solid;
            padding: 5px;
        }
    </style>
</head>

<body>
    <h1>배열</h1>
    <p>

        - 변수 선언시 별도의 자료형 지정하지 않음<br>
        - 어떤 자료형의 값들이든 다 하나의 배열 공간에 담을 수 있음,(스트링과 인트, 논리형을 하나의 배열에 담을 수 있다?)
        크기에 제약도 없다(자바의 컬렉션과 유사)
        - 존재하지 않는 인덱스를 참조해도 오류나지 않음. undefined 리턴
    </p>

    <button onclick="arrayTest1();">배열 확인</button>
    <div class="area" id="area1"></div>

    <script>
        function arrayTest1() {
            let arr = ['홍길동', "서울", 20, true, [1, 2, 3]];
            console.log(arr);
            console.log(arr[2]);
            console.log(arr[4]);
            console.log(arr[4][2]);
            console.log(arr[5]);

            const area1 = document.getElementById('area1');
            for (let i = 0; i < arr.length; i++) {
                area1.innerHTML += arr[i] + '<br>';

            }
        }
    </script>

    <hr>
    <h3> * 배열의 선언</h3>
    <button onclick="arrayTest2();">배열 선언 확인</button>
    <script>
        function arrayTest2() {
            let array1 = new Array();
            let array2 = new Array(3);
            let array3 = [];
            console.log(array1);
            console.log(array2);
            console.log(array3);

            //배열에 값 대입
            array1[0] = '바나나';
            array1[1] = '사과';
            array1[2] = '키위';

            console.log(array1);

            //배열 길이를 미리 선언해도 그 길이를 넘어서 값을 넣을 수 있다.
            array2[0] = '자동차';
            array2[1] = '오도방';
            array2[2] = '기차';
            array2[3] = '비행기';
            console.log(array2);

            //배열 선언과 동시에 초기ㅗ하
            let arr4 = new Array('홍길동', '임꺽정', '신사임당');
            let arr5 = ['java', 'html', 'css'];

            console.log(arr4);
            console.log(arr5);
        }
    </script>


    <hr>
    <h3>* 배열관련 메소드</h3>

    <h4>1) 배열.indexOf(찾고자하는 요소) : 배열에서 해당 요소 위치의 인덱스를 반환</h4>
    <button onclick="indexOfTest();">indexOf</button>
    <div class="area" id="area2"></div>
    <script>
        function indexOfTest() {
            let arr = ['사과', '딸기', '복숭아', '수박', '참외'];
            let fruit = prompt('먹고싶은 과일명 입력');

            let index = arr.indexOf(fruit);
            console.log(index);
            //당신이 찾는 과일 ???는 ?번째 인덱스에 있습니다.
            //당신이 찾는 과일 ???는 판매하지 않습니다.
            let divE1 = document.getElementById('area2');
            if (index != -1) {
                divE1.innerHTML = `당신이 찾는 과일 ${fruit}은(는) ${index}번쨰 인덱스에 있습니다.`;
            } else {
                divE1.innerHTML = `당신이 찾는 과일 ${fruit}은(는) 판매하지 않습니다.`;
            }

            //자바스크립트에서 두 값이 동일한지 비교하는 연산자
            console.log(1 == 1);      //true
            console.log(1 == '1');    //true => 동등연산자(자료형과 무관하게 실제값만 일치해도 true)
            console.log(1 === '1');   //false =>엄격동등비교 (값, 자료형 둘 다 일치해야만 true)

        }
    </script>
    <br>

    <hr>

    <h4>2) 배열.concat(배열, 배열, .....) : 배열 여러개를 결합하고자 할 떄 사용</h4>

    <button onclick="concatTest();">concat</button>
    <div class="area" id="area3"></div>

    <script>
        function concatTest() {
            const divE2 = document.querySelector("#area3");

            const arr1 = ['사과', '딸기'];
            const arr2 = ['자동차', '비행기', '오도방'];

            divE2.innerHTML += `arr1 : ${arr1}<br>`;
            divE2.innerHTML += `arr2 : ${arr2}<br>`;

            divE2.innerHTML += `arr1 기준으로 배열 합침 : ${arr1.concat(arr2)}<br>`;
            divE2.innerHTML += `원본 arr1 : ${arr1}<br>`;
            //배열을 합친다고 원본 배열이 바뀌지 않고 기준으로 하는 배열이 앞에 붙고 붙일려는 배열은 그 뒤에 붙는다.

            divE2.innerHTML += `arr2 기준으로 배열 합침 : ${arr2.concat(arr1, [1, 2, 3])}<br>`;

        }

    </script>

    <br>
    <hr>
    <h4>3) 배열.reverse() : 배열에 담긴 값들을 역순으로 바꿔주는 메소드</h4>

    <button onclick="reverseTest();">reverse</button>
    <div class="area" id="area4"></div>

    <script>
        function reverseTest() {
            divE3 = document.querySelector("#area4");

            let arr = [1, 2, 3, 4, 5];
            divE3.innerHTML += `arr : ${arr}<br>`;
            divE3.innerHTML += `reverse 결과 : ${arr.reverse()}<br>`;
            divE3.innerHTML += `arr 원본 : ${arr}<br>`;
            //원본 배열에 영향을 끼치는 메소드
        }
    </script>
    <br>

    <hr>
    <h4>4) 배열.sort() : 배열에 담긴 값들을 오름차순으로 정렬시켜주는 메소드</h4>
    <button onclick="sortTest();">sort</button>
    <div class="area" id="area5"></div>

    <script>
        function sortTest() {
            const divE4 = document.getElementById('area5');

            let arr = ['박길동', '김길동', '홍길동', '나길동', '강길동'];

            divE4.innerHTML += `arr : ${arr}<br>`;
            divE4.innerHTML += `sort결과 : ${arr.sort()}<br>`;
            divE4.innerHTML += `원본 arr ${arr}<br>`;
            //원본 배열에 영향을 끼치는 메소드

            //내림차순으로 정렬하고 싶다면 자바스크립트의 배열에 내림차순 정렬 메소드는 없으므로 sort를 한 후 reverse를 해주면 된다.

            divE4.innerHTML += `내림차순 정렬 : ${arr.sort().reverse()}<br>`;
        }
    </script>
    <br>
    <hr>
    <h4>5.1) 배열.push(추가할 요소) : 배열의 맨 뒤에 요소를 추가시키고 배열의 크기를 반환<br>
        5.2) 배열.pop() : 배열의 맨 뒤 요소를 제고하고 제거된 요소를 반환<br>
    </h4>

    <button onclick="pushPopTest();">PUSH_POP</button>
    <div class="area" id="area6"></div>

    <script>
        function pushPopTest() {
            const divE5 = document.querySelector('#area6');

            const arr = ['서초동', '방배동', '역삼동', '삼성동', '대치동'];

            divE5.innerHTML += `<b>arr </b>: ${arr}<br>`;
            divE5.innerHTML += `<b>arr 맨 뒤에 추가(push) </b>: ${arr.push('구로동')}<br>`;
            divE5.innerHTML += `<b>원본 arr </b>: ${arr}<br>`;
            arr.push('잠실본동');
            divE5.innerHTML += `<b>arr 맨뒤에 추가한 후 </b>: ${arr}<br>`;
            divE5.innerHTML += `-----------------------------------------------------------------------------------<br>`;

            divE5.innerHTML += `<b>arr의 맨뒤요소 제거(pop)</b> : ${arr.pop()}<br>`;
            divE5.innerHTML += `<b>원본 arr</b> : ${arr}<br>`;

            arr.pop();
            arr.pop();
            divE5.innerHTML += `<b>최종 arr </b>: ${arr}<br>`;
        }
    </script>

    <br>

    <hr>

    <h4>
        6.1)배열.unshift(추가할 요소) : 배열의 맨앞에 요소 추가한 후 배열의 크기 반환<br>
        6.2)배열.shift() : 배열의 맨 앞의 요소를 제거하고 제거된 요소 반환<br>
    </h4>

    <button onclick="unshiftTest();">SHIFT_UNSHIFT</button>
    <div class="area" id="area7"></div>

    <script>
        function unshiftTest() {
            const divE6 = document.getElementById('area7');

            const arr = ['테니스', '볼링', '야구', '당구'];

            divE6.innerHTML += `<b>원본 arr </b>: ${arr}<br>`;
            
            arr.unshift('농구');
            divE6.innerHTML += `<b>arr에 농구를 unshif한 후 </b>: ${arr}<br>`;

            arr.shift();
            divE6.innerHTML += `<b>arr에 shift를 한 후 </b>: ${arr}<br>`;
        }
    </script>

    <br>

    <hr>

    <h4>
        7.1) 배열.slice(시작인덱스) : 배열의 시작인덱스부터 맨끝 인덱스까지 추출해주는 메소드(원본이 변경되지 않음)<br>
        7.2) 배열.slice(시작인덱스, 끝인덱스) : 배열에서 시작인덱스부터 끝인덱스까지 추출해주는 메소드(원본이 변경되지 않음)<br>
        7.3) 배열.splice(시작인덱스,제거할 수, 추가할 값, ....) : 배열의 요소를 추출하여 제거 및 추가를 해준다.(원본이 변경됨) <br>
    </h4>

    <button onclick="sliceTest();">SLICE_SPLICE</button>
    <div class="area" id="area8"></div>
    <script>
        function sliceTest() {
            const divE7 = document.querySelector('#area8');

            let arr = ['java', 'oracle', 'html', 'css', 'javascript'];
            divE7.innerHTML += `<b>원본 arr </b>: ${arr}<br>`;
            divE7.innerHTML += `<b>slice (2,4) </b>: ${arr.slice(2, 4)}<br>`;
            divE7.innerHTML += `<b>slice(3) </b>: ${arr.slice(3)}<br>`;

            divE7.innerHTML += `<b>원본 arr </b>: ${arr}<br>`;
            divE7.innerHTML += `<b>splice(2,2,'jQuery','JSP') </b>: ${arr.splice(2, 2, 'jQuery', 'JSP')}<br>`;
            divE7.innerHTML += `<b>원본 arr </b>: ${arr}<br>`;
        }
    </script>

    <h4>
        8) 배열.toString() / 배열.join([구분자]) : 배열의 각 인덱스에 담긴 값들을 하나의 '문자열'로 합쳐서 반환<br>
            - toString : 구분자를 지정해줄 수 없어서 항상 ,로 구분된다
            - join : 구분자를 지정해 줄 수 있어서 ,가 아닌 공백( )으로 구분하여 문장으로 만들 수 있다. 
    </h4>

    <button onclick="toStringJoinTest();">TOSTRING</button>
    <div class="area" id="area9"></div>

    <script>
        function toStringJoinTest() {
            const divE8 = document.querySelector("#area9");

            const arr = ["나눈", '오늘', '맛있는', '뼉다구해장국을', '먹었어'];
            divE8.innerHTML += `<b>arr </b>: ${arr}<br>`;
            console.log(typeof arr);        //object
            divE8.innerHTML += `<b>toString</b> : ${arr.toString()}<br>`;
            console.log(typeof arr);        //object

            divE8.innerHTML += `<b>join</b> : ${arr.join()}<br>`;
            divE8.innerHTML += `<b>구분자을 제시한 join</b> : ${arr.join(' ')}<br>`;
            //각 인덱스를 구분하는 기본값은 콤마(,)인데 join괄호 안에 구분을 원하는 값을 넣어주면 그걸로 구분하여 출력한다.

        }
    </script>

    <hr>

    <h4>9) 반복처리(for문, for..in문, for..of문, forEach)</h4>

    <button onclick="forEach();">forEach</button>
    <div class="area" id="area10"></div>

    <script>
        function forEach() {
            const divE9 = document.getElementById('area10');
            const arr = ['가', '나', '다'];

            divE9.innerHTML += `for : `;
            for (let i = 0; i < arr.length; i++) {
                divE9.innerHTML += `${arr[i]}`;
            }
            divE9.innerHTML += `<br>`;

            //배열에 대해 인덱스 속성 가져오기(향상된 for문과 일반 for문 사이 어딘가)
            divE9.innerHTML += `for in : `;
            for (let i in arr) {
                divE9.innerHTML += `${i} : ${arr[i]},`;
            }
            divE9.innerHTML += `<br>`;

            //배열의 요소 가져오기  (향상된 for문 개념)
            divE9.innerHTML += `for of : `;
            for (let ch of arr) {
                divE9.innerHTML += `${ch}, `;
            }
            divE9.innerHTML += `<br>`;

            // forEach메소드 : 각 요소별로 전달한 함수(콜백함수)를 실행
            //콕백함수 : 매개변수가 들어가는 자리에 들어가는 함수
            divE9.innerHTML += `forEach : <br>`;

            //forEach는 바로 뒤에 function구문이 들어가서 매개변수와 실행부를 써줘야 한다.
            arr.forEach(function (elem, index, arr) {
                divE9.innerHTML += `${elem}, ${index}, ${arr}<br>`;
            })
            /*   
                 <출력 결과>
                 가, 0, 가,나,다
                 나, 1, 가,나,다
                 다, 2, 가,나,다
            */
            //각 인덱스별 값만 필요한 경우
            divE9.innerHTML += `arr.forEach(function(elem))<br>`;
            arr.forEach(function (elem) {
                divE9.innerHTML += `${elem}<br>`;
            })

            //각 인덱스값만 필요한 경우
            divE9.innerHTML += `arr.forEach(function(elem,index))<br>`;
            arr.forEach(function (elem, index) {
                divE9.innerHTML += `${index}<br>`;
            })



        }
    </script>

    <br>

    <hr>

    <h4>
        (forEach와의 차이점은 배열로 반환할 것인가 아니면 바로 페이지에 출력해줄것인가)<br>
        <!-- 홈페이지 만들떄는 잘 안쓰지만 react할떄는 어어엄청 쓸것이지 잘 알아둘것 -->
        10.1) map : 배열의 각 요소별로 작업한 후 요소를 담은 배열 반환<br>
        <!-- map : 각 인덱스별 값의 가공이 필요한 경우 입맛대로 가공하여 새로운 배열로 return -->
        10.2) filter : 각 요소별 콜백함수를 실행하여 true인 요소만 새 배열에 담아 반환<br>
        <!-- filter : 배열에 있는 값들 중 특정 조건에 부합하는 값만 따로 가져와야할때 
                      조건식을 만들어 입맛대로 가져올 수 있다. -->
        10.3) reduce : 모든 요소를 대상으로 특정작업 후 하나의 값(객체)로 반환(ex sum, avg)<br>
        - 최대 / 최솟값, 누적합 등에 적합<br>
        - reduce(콜백함수, 초기값) : 초기값을 생략하면 배열의 첫번째 요소가 초기값이 된다.
    </h4>

    <button onclick="map();">MAP</button>&emsp;
    <button onclick="filter();">FILTER</button>&emsp;
    <button onclick="reduce();">REDUCE</button>&emsp;

    <div class="area" id="area11">
        <ul></ul>
    </div>

    <script>
        //map을 쓰면 자동으로 for문이 돈다고 생각하자
        const divE10 = document.querySelector("#area11>ul");
        function map() {
            let arr = [1, 2, 3];  //[1, 4, 9] **[1*1, 2*2, 3*3]을 얻고 싶을때
            let result = arr.map(function (value, index, arr) {
                console.log(value, index, arr);
                return value * value;
            });
            console.log(arr);
            console.log(result);

            let names = ['김말똥', '이순신', '김나무'];

            let nameList = names.map(function (name) {
                return `<li>${name}</li>`;
            })

            console.log(nameList);

            // for(let i = 0 ;i<nameList.length;i++){
            //     divE10.innerHTML +=nameList[i];
            // }

            //for in(index번호)
            // for(let i in nameList){
            //     divE10.innerHTML += nameList[i];
            // }

            //for of(요소값)
            // for(let j of nameList){
            //     divE10.innerHTML += j;
            // }

            //forEach
            nameList.forEach(function (value, index) {
                divE10.innerHTML += value;
                // divE10.innerHTML += nameList[index];
            })
        }

        function filter() {
            let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            let even = nums.filter(function (n, index, arr) {
                return n % 2 == 0;
            })
            divE10.innerHTML += `<li>${even}</li>`;
            //1) 1~100까지 배열에 담기   //담을떄는 자바처럼 arr[i]=i;하지 말고 arr.push(i)로 하자 그럼 배열 길이를 미리 정해주지 않아도 된다.
            //2) 31이하의 숫자중 3의 배수만 가져오는 filter

            let arr=[];
            for(let i = 1;i<=100;i++){
                arr.push(i);
            }
            // console.log(arr);
            let filter3=arr.filter(function(value){
                return value<=31&&value%3==0;
            })
            console.log(filter3);
            divE10.innerHTML += `<li>${filter3}</li>`;
        }

        function reduce() {
            // reduce의 콜백함수에 들어가는 매개변수는 아래와 같이 4개이다.
            // allbackfn(previousValue: number(이전값), currentValue: number(현재값), currentIndex: number, array: number[]): number
            let arr = [1,2,3,4,5,6,7,8,9,10];
            let sum = arr.reduce(function(pv, elem, index, arr){
                console.log(pv, elem);
                return pv+elem; //이전값과 현재값을 더한것이 다음 index의 이전값이 된다는 뜻이다.
                // return pv * 3을 하면 3의 제곱들을 알 수 있다.
            })
            console.log(`sum : ${sum}<br>`);
            divE10.innerHTML += `<li>1~10까지의 합 : ${sum}</li>`;

            //초기값 따로 지정
            let sum2 = arr.reduce(function(pv, elem, index, arr){
                console.log(pv, elem);
                return pv+elem; 
            },0)  //여기에 입력한 0은 초기값을 뜻한다(첫 번째 pv값)
            console.log(arr);

            //최대값
            let nums = [4,9,5,6,2,3,7,8,1,10];
            let max = nums.reduce(function(previous,current){
                return previous > current ? previous : current;  //3항 연산자로 정렬기준을 지정해주어 가장 큰값을 뽑아낸다.
            })
            divE10.innerHTML += `<li>nums에서 가장 큰값 : ${max}</li>`;
            
            //최소값
            let min = nums.reduce(function(pv,cv){
                return pv > cv ? cv : pv;
            })
            divE10.innerHTML+= `<li>nums에서 가장 작은 값 : ${min}</li>`;
            
            //nums에서의 짝수의 갯수
            let count1=0;
            let count = nums.reduce(function(pv,cv){
               if(cv%2==0)
                   count1 +=1;
                return count1;
                
            },1)
            divE10.innerHTML+= `<li>nums에서 짝수의 갯수 : ${count}</li>`;
            





        }

    </script>














    <br><br><br><br><br><br><br><br><br><br>
</body>

</html>